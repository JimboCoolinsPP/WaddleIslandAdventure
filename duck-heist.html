// ===== LEVEL SYSTEM =====
let currentLevel = 1;
const maxLevels = 3;
let levelConfig = {
    1: {
        timeLimit: 60,
        guardCount: 3,
        guardSpeed: 3,
        breadCount: 5,
        obstacleCount: 5,
        goldBreadChance: 0.3,
        guardVisionRange: 120
    },
    2: {
        timeLimit: 50,
        guardCount: 4,
        guardSpeed: 3.5,
        breadCount: 7,
        obstacleCount: 7,
        goldBreadChance: 0.4,
        guardVisionRange: 130
    },
    3: {
        timeLimit: 45,
        guardCount: 5,
        guardSpeed: 4,
        breadCount: 10,
        obstacleCount: 8,
        goldBreadChance: 0.5,
        guardVisionRange: 140
    }
};

// Add to the HTML, before the script tag
// <!-- Add this for the level indicator -->
// <div id="level-indicator">Level 1</div>
// <div id="level-complete">
//     <h2>Level Complete!</h2>
//     <div id="level-stats"></div>
//     <button id="next-level-btn">Next Level</button>
// </div>
// <div id="game-complete">
//     <h2>Game Complete!</h2>
//     <div id="final-stats"></div>
//     <button id="play-again-btn">Play Again</button>
// </div>
// <audio id="collect-sound" src="https://actions.google.com/sounds/v1/cartoon/pop.ogg" preload="auto"></audio>
// <audio id="gold-sound" src="https://actions.google.com/sounds/v1/cartoon/cartoon_boing.ogg" preload="auto"></audio>
// <audio id="level-up-sound" src="https://actions.google.com/sounds/v1/cartoon/cartoon_cowbell.ogg" preload="auto"></audio>
// <audio id="alert-sound" src="https://actions.google.com/sounds/v1/alarms/bugle_alert.ogg" preload="auto"></audio>
// <audio id="power-up-sound" src="https://actions.google.com/sounds/v1/cartoon/siren_whistle.ogg" preload="auto"></audio>

// Add these CSS styles
/*
#level-indicator {
    position: absolute;
    top: 10px;
    right: 10px;
    background-color: rgba(0, 0, 0, 0.6);
    color: #ffcc00;
    padding: 5px 10px;
    border-radius: 5px;
    font-family: Arial, sans-serif;
    font-weight: bold;
    font-size: 18px;
    z-index: 10;
}

#level-complete, #game-complete {
    display: none;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background-color: rgba(0, 0, 0, 0.85);
    color: white;
    padding: 20px 30px;
    border-radius: 10px;
    text-align: center;
    z-index: 100;
    border: 3px solid #ffcc00;
    width: 80%;
    max-width: 400px;
}

#level-stats, #final-stats {
    margin: 15px 0;
    font-size: 18px;
    line-height: 1.5;
}

#next-level-btn, #play-again-btn {
    background-color: #ffcc00;
    border: none;
    color: #333;
    padding: 10px 20px;
    font-size: 18px;
    border-radius: 5px;
    cursor: pointer;
    font-weight: bold;
    margin-top: 10px;
    transition: all 0.2s;
}

#next-level-btn:hover, #play-again-btn:hover {
    background-color: #ffdd33;
    transform: scale(1.05);
}

.score-popup {
    position: absolute;
    color: #ffcc00;
    font-weight: bold;
    font-size: 20px;
    pointer-events: none;
    animation: float-up 1s forwards;
    text-shadow: 0px 0px 5px rgba(0, 0, 0, 0.8);
}

@keyframes float-up {
    0% { transform: translateY(0); opacity: 1; }
    100% { transform: translateY(-50px); opacity: 0; }
}
*/

// ===== ENHANCED BREAD SYSTEM WITH GOLD BREAD =====
function initializeBread() {
    // Clear existing bread
    breadItems = [];
    
    // Get level config
    const config = levelConfig[currentLevel];
    
    // Generate regular bread
    for (let i = 0; i < config.breadCount; i++) {
        const isGoldBread = Math.random() < config.goldBreadChance;
        const breadItem = {
            x: 0, 
            y: 0, 
            width: 20, 
            height: 20,
            isGold: isGoldBread,
            value: isGoldBread ? 5 : 1,
            collectTime: 0 // For animation
        };
        
        const validPos = getValidPosition(breadItem);
        breadItem.x = validPos.x;
        breadItem.y = validPos.y;
        
        breadItems.push(breadItem);
    }
}

function drawBreadItems() {
    breadItems.forEach(bread => {
        // Regular bread
        if (!bread.isGold) {
            ctx.fillStyle = "#d4a76a";
            ctx.beginPath();
            ctx.arc(bread.x + 10, bread.y + 10, 10, 0, Math.PI * 2);
            ctx.fill();
            
            // Add details to bread
            ctx.fillStyle = "#b58b4c";
            ctx.beginPath();
            ctx.arc(bread.x + 7, bread.y + 8, 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(bread.x + 13, bread.y + 12, 2, 0, Math.PI * 2);
            ctx.fill();
        } 
        // Gold bread with animation
        else {
            // Gold bread animation
            const pulse = 1 + 0.1 * Math.sin(Date.now() / 200);
            const glow = Math.abs(Math.sin(Date.now() / 300)) * 10;
            
            // Draw glow
            ctx.fillStyle = `rgba(255, 215, 0, ${0.2 + Math.abs(Math.sin(Date.now() / 400)) * 0.3})`;
            ctx.beginPath();
            ctx.arc(bread.x + 10, bread.y + 10, 15 + glow, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw gold bread
            ctx.fillStyle = "#FFD700";
            ctx.beginPath();
            ctx.arc(bread.x + 10, bread.y + 10, 10 * pulse, 0, Math.PI * 2);
            ctx.fill();
            
            // Add sparkle effect
            if (Math.random() < 0.1) {
                const sparkleSize = 2 + Math.random() * 3;
                const sparkleX = bread.x + 10 + (Math.random() * 20 - 10);
                const sparkleY = bread.y + 10 + (Math.random() * 20 - 10);
                
                ctx.fillStyle = "#FFFFFF";
                ctx.beginPath();
                ctx.arc(sparkleX, sparkleY, sparkleSize, 0, Math.PI * 2);
                ctx.fill();
            }
        }
    });
}

// ===== ENHANCED SCORING SYSTEM =====
let totalScore = 0;
let levelScore = 0;
let scoreMultiplier = 1;
let timeBonus = 0;
let breadCollected = 0;
let goldBreadCollected = 0;
let perfectLevelBonus = 100;

function updateScore(points, x, y) {
    // Update score
    levelScore += points * scoreMultiplier;
    totalScore += points * scoreMultiplier;
    
    // Show floating score text
    createFloatingText(`+${points * scoreMultiplier}`, x, y, points > 1 ? "#FFD700" : "#FFFFFF");
    
    // Update UI
    updateScoreDisplay();
}

function createFloatingText(text, x, y, color = "#FFFFFF") {
    const scorePopup = document.createElement("div");
    scorePopup.className = "score-popup";
    scorePopup.innerText = text;
    scorePopup.style.left = `${x}px`;
    scorePopup.style.top = `${y}px`;
    scorePopup.style.color = color;
    
    gameContainer.appendChild(scorePopup);
    
    // Remove after animation completes
    setTimeout(() => {
        gameContainer.removeChild(scorePopup);
    }, 1000);
}

function updateScoreDisplay() {
    // We'll update this in drawGameInfo
}

function handleBreadCollision() {
    breadItems.forEach((bread, index) => {
        if (checkCollision(duck, bread)) {
            // Play appropriate sound
            const soundEffect = bread.isGold ? 
                document.getElementById("gold-sound") : 
                document.getElementById("collect-sound");
                
            soundEffect.currentTime = 0;
            soundEffect.play();
            
            // Update counters
            if (bread.isGold) {
                goldBreadCollected++;
            } else {
                breadCollected++;
            }
            
            // Update score
            updateScore(bread.value, bread.x, bread.y);
            
            // Remove collected bread
            breadItems.splice(index, 1);
            
            // Check if level is complete (all bread collected)
            if (breadItems.length === 0) {
                completeLevel();
            }
        }
    });
}

// ===== SOUND SYSTEM =====
function initializeSounds() {
    // Sound elements already added in the HTML
    
    // Add volume control
    const sounds = [
        "collect-sound", "gold-sound", "level-up-sound", 
        "alert-sound", "power-up-sound"
    ];
    
    sounds.forEach(id => {
        const sound = document.getElementById(id);
        if (sound) {
            sound.volume = 0.3; // Adjust default volume
        }
    });
}

function playSound(id) {
    const sound = document.getElementById(id);
    if (sound) {
        sound.currentTime = 0;
        sound.play().catch(e => console.log("Sound play error:", e));
    }
}

// ===== LEVEL PROGRESSION =====
function initializeLevel(level) {
    currentLevel = level;
    const config = levelConfig[level];
    
    // Reset game state
    levelScore = 0;
    breadCollected = 0;
    goldBreadCollected = 0;
    timeLeft = config.timeLimit;
    
    // Update level indicator
    const levelIndicator = document.getElementById("level-indicator");
    if (levelIndicator) {
        levelIndicator.textContent = `Level ${level}`;
    }
    
    // Reset duck position
    duck = { 
        x: 50, 
        y: 300, 
        width: 50, 
        height: 50, 
        speed: 10, 
        isInvisible: false
    };
    
    // Generate obstacles based on level
    obstacles = [];
    for (let i = 0; i < config.obstacleCount; i++) {
        const obstacle = {
            x: Math.random() * (CANVAS_WIDTH - 100),
            y: Math.random() * (CANVAS_HEIGHT - 100),
            width: 40 + Math.random() * 60,
            height: 30 + Math.random() * 80,
            type: Math.floor(Math.random() * 3)
        };
        
        // Ensure obstacles don't overlap with duck starting position
        if (
            obstacle.x < duck.x + duck.width + 50 && 
            obstacle.x + obstacle.width > duck.x - 50 &&
            obstacle.y < duck.y + duck.height + 50 && 
            obstacle.y + obstacle.height > duck.y - 50
        ) {
            i--; // Try again
            continue;
        }
        
        obstacles.push(obstacle);
    }
    
    // Generate guards based on level
    guards = [];
    for (let i = 0; i < config.guardCount; i++) {
        const guard = {
            x: 400 + (Math.random() * 300),
            y: 200 + (Math.random() * 300),
            width: 40,
            height: 40,
            speed: config.guardSpeed - 0.5 + Math.random(),
            canSeePlayer: false,
            visionRange: config.guardVisionRange - 10 + Math.random() * 20,
            patrolTargetX: undefined,
            patrolTargetY: undefined
        };
        
        // Ensure guards don't start too close to player
        if (
            guard.x < duck.x + duck.width + 200 && 
            guard.x + guard.width > duck.x - 200 &&
            guard.y < duck.y + duck.height + 200 && 
            guard.y + guard.height > duck.y - 200
        ) {
            i--; // Try again
            continue;
        }
        
        guards.push(guard);
    }
    
    // Initialize bread with gold bread
    initializeBread();
    
    // Initialize power-ups
    initializePowerUps();
    
    // Hide UI elements
    document.getElementById("level-complete").style.display = "none";
    document.getElementById("game-complete").style.display = "none";
    document.getElementById("restart-btn").style.display = "none";
    
    // Game is now active
    gameOver = false;
}

function completeLevel() {
    // Calculate time bonus
    timeBonus = timeLeft * 5;
    
    // Calculate perfect level bonus - all gold bread collected
    const perfectBonus = (goldBreadCollected === Math.floor(levelConfig[currentLevel].breadCount * levelConfig[currentLevel].goldBreadChance)) ? 
        perfectLevelBonus : 0;
    
    // Calculate final level score
    const finalLevelScore = levelScore + timeBonus + perfectBonus;
    totalScore += timeBonus + perfectBonus;
    
    // Stop the timer
    gameOver = true;
    
    // Show level complete UI
    const levelComplete = document.getElementById("level-complete");
    const levelStats = document.getElementById("level-stats");
    
    levelStats.innerHTML = `
        <p>Bread Collected: ${breadCollected + goldBreadCollected}</p>
        <p>Gold Bread: ${goldBreadCollected}</p>
        <p>Time Bonus: ${timeBonus}</p>
        ${perfectBonus > 0 ? `<p>Perfect Bonus: ${perfectBonus}</p>` : ''}
        <p>Level Score: ${finalLevelScore}</p>
        <p>Total Score: ${totalScore}</p>
    `;
    
    levelComplete.style.display = "block";
    
    // Play level complete sound
    playSound("level-up-sound");
    
    // Setup next level button
    const nextLevelBtn = document.getElementById("next-level-btn");
    if (nextLevelBtn) {
        if (currentLevel < maxLevels) {
            nextLevelBtn.innerText = "Next Level";
            nextLevelBtn.onclick = () => {
                initializeLevel(currentLevel + 1);
            };
        } else {
            nextLevelBtn.innerText = "See Final Score";
            nextLevelBtn.onclick = () => {
                completeGame();
            };
        }
    }
}

function completeGame() {
    // Hide level complete
    document.getElementById("level-complete").style.display = "none";
    
    // Show game complete
    const gameComplete = document.getElementById("game-complete");
    const finalStats = document.getElementById("final-stats");
    
    finalStats.innerHTML = `
        <p>You've completed all ${maxLevels} levels!</p>
        <p>Final Score: ${totalScore}</p>
        <p>Thanks for playing Duck Heist!</p>
    `;
    
    gameComplete.style.display = "block";
    
    // Setup play again button
    const playAgainBtn = document.getElementById("play-again-btn");
    if (playAgainBtn) {
        playAgainBtn.onclick = () => {
            // Reset total score
            totalScore = 0;
            
            // Hide game complete
            gameComplete.style.display = "none";
            
            // Start from level 1
            initializeLevel(1);
        };
    }
}

function endGame(message) {
    gameOver = true;
    
    // Draw semi-transparent overlay
    ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
    ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
    
    // Draw message box
    ctx.fillStyle = "#333";
    ctx.fillRect(CANVAS_WIDTH/2 - 250, CANVAS_HEIGHT/2 - 100, 500, 200);
    ctx.strokeStyle = "#ffcc00";
    ctx.lineWidth = 4;
    ctx.strokeRect(CANVAS_WIDTH/2 - 250, CANVAS_HEIGHT/2 - 100, 500, 200);
    
    // Draw game over message
    ctx.fillStyle = "#ffcc00";
    ctx.font = "bold 36px Arial";
    ctx.textAlign = "center";
    ctx.fillText(message, CANVAS_WIDTH/2, CANVAS_HEIGHT/2 - 50);
    
    // Draw score
    ctx.fillStyle = "white";
    ctx.font = "24px Arial";
    ctx.fillText(`Level Score: ${levelScore}`, CANVAS_WIDTH/2, CANVAS_HEIGHT/2);
    ctx.fillText(`Total Score: ${totalScore}`, CANVAS_WIDTH/2, CANVAS_HEIGHT/2 + 40);
    
    // Reset text alignment
    ctx.textAlign = "left";
    
    document.getElementById("restart-btn").style.display = "block";
}

// Update restart button functionality
document.getElementById("restart-btn").addEventListener("click", () => {
    // Keep total score but reset level
    initializeLevel(currentLevel);
});

// ===== ENHANCED GAME INFO =====
function drawGameInfo() {
    // Draw background for HUD
    ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
    ctx.fillRect(10, 10, 200, 90);
    ctx.strokeStyle = "#ffcc00";
    ctx.lineWidth = 2;
    ctx.strokeRect(10, 10, 200, 90);
    
    // Bread score
    ctx.fillStyle = "white";
    ctx.font = "bold 20px Arial";
    ctx.fillText(`Score: ${totalScore}`, 20, 35);
    
    // Bread count
    const breadLeft = breadItems.length;
    const goldLeft = breadItems.filter(b => b.isGold).length;
    const regularLeft = breadLeft - goldLeft;
    
    ctx.fillText(`Regular: ${regularLeft}`, 20, 60);
    ctx.fillStyle = "#FFD700";
    ctx.fillText(`Gold: ${goldLeft}`, 20, 85);
    
    // Time left
    ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
    ctx.fillRect(CANVAS_WIDTH - 120, 10, 110, 40);
    ctx.strokeStyle = "#ffcc00";
    ctx.strokeRect(CANVAS_WIDTH - 120, 10, 110, 40);
    
    ctx.fillStyle = timeLeft <= 10 ? "#ff4444" : "white";
    ctx.font = "bold 24px Arial";
    ctx.fillText(`Time: ${timeLeft}`, CANVAS_WIDTH - 110, 37);
    
    // Level indicator
    ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
    ctx.fillRect(CANVAS_WIDTH - 120, 60, 110, 40);
    ctx.strokeStyle = "#ffcc00";
    ctx.strokeRect(CANVAS_WIDTH - 120, 60, 110, 40);
    
    ctx.fillStyle = "#ffcc00";
    ctx.fillText(`Level: ${currentLevel}`, CANVAS_WIDTH - 110, 87);
    
    // Draw game border
    ctx.strokeStyle = "#ffcc00";
    ctx.lineWidth = 3;
    ctx.strokeRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
}

// ===== ENHANCED GUARD AI =====
// Update the canSeePlayer function for alert sound
function updateGuardVision() {
    guards.forEach(guard => {
        const previouslySpotted = guard.canSeePlayer;
        guard.canSeePlayer = canSeePlayer(guard);
        
        // If guard just spotted player, play alert sound
        if (!previouslySpotted && guard.canSeePlayer) {
            playSound("alert-sound");
        }
    });
}

// ===== GAMEPLAY IMPROVEMENTS =====
// Power-up handling with sound
function handlePowerUpCollisions() {
    powerUps.forEach(powerUp => {
        if (!powerUp.active && checkCollision(duck, powerUp)) {
            // Play power-up sound
            playSound("power-up-sound");
            
            // Activate power-up
            powerUp.active = true;
            powerUp.timeLeft = powerUp.duration;
            
            // Apply power-up effect
            if (powerUp.type === "speed") {
                duck.originalSpeed = duck.speed;
                duck.speed = duck.speed * 1.6;
            } else if (powerUp.type === "invisible") {
                duck.isInvisible = true;
            }
            
            // Create floating text
            createFloatingText(
                powerUp.type === "speed" ? "Speed Boost!" : "Invisibility!", 
                powerUp.x, 
                powerUp.y, 
                powerUp.type === "speed" ? "#FFD700" : "#9370DB"
            );
            
            // Start countdown timer
            const powerUpInterval = setInterval(() => {
                if (gameOver || powerUp.timeLeft <= 0) {
                    // Deactivate power-up
                    if (powerUp.type === "speed") {
                        duck.speed = duck.originalSpeed;
                    } else if (powerUp.type === "invisible") {
                        duck.isInvisible = false;
                    }
                    
                    // Reset power-up
                    powerUp.active = false;
                    const validPos = getValidPosition(powerUp);
                    powerUp.x = validPos.x;
                    powerUp.y = validPos.y;
                    
                    clearInterval(powerUpInterval);
                } else {
                    powerUp.timeLeft--;
                }
            }, 1000);
        }
    });
}

// ===== MAIN GAME UPDATES =====
// Update the updateGame function to handle all new systems
function updateGame() {
    if (gameOver) return;
    ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
    
    drawBackground();
    handleMovement();
    updateGuardVision();
    moveGuards();
    handleCollisions();
    handleBreadCollision();
    handlePowerUpCollisions();
    
    drawObstacles();
    drawBreadItems();
    drawPowerUps();
    drawGuards();
    drawDuck();
    drawGameInfo();
    drawPowerUpStatus();
}

// Update handleCollisions to work with breadItems array
function handleCollisions() {
    // Check guard collisions
    guards.forEach(guard => {
        if (checkCollision(duck, guard)) {
            endGame("Caught by security! Game Over.");
        }
    });

    // Obstacle collisions
    obstacles.forEach(obstacle => {
        if (checkCollision(duck, obstacle)) {
            const overlapX = duck.x < obstacle.x ? 
                duck.x + duck.width - obstacle.x : 
                obstacle.x + obstacle.width - duck.x;
            const overlapY = duck.y < obstacle.y ? 
                duck.y + duck.height - obstacle.y : 
                obstacle.y + obstacle.height - duck.y;
            
            if (Math.abs(overlapX) < Math.abs(overlapY)) {
                duck.x += overlapX > 0 ? -overlapX : Math.abs(overlapX);
            } else {
                duck.y += overlapY > 0 ? -overlapY : Math.abs(overlapY);
            }
        }
    });
}

// Initialize the game with level system
// Replace your current initialization with this
document.addEventListener("DOMContentLoaded", function () {
    // ... (existing setup code)
    
    // Initialize sounds
    initializeSounds();
    
    // Start with level 1
    initializeLevel(1);
    
    // Game loop stays the same
    function gameLoop() {
        updateGame();
        requestAnimationFrame(gameLoop);
    }
    gameLoop();
});

// Update the timer to include level completion check
const gameTimer = setInterval(() => {
    if (!gameOver && timeLeft > 0) {
        timeLeft--;
        
        // If time runs out
        if (timeLeft <= 0) {
            endGame("Time's up! Game Over.");
        }
    }
}, 1000);

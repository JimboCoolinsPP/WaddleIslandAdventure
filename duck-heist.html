// Duck Breadcrumb Collection Game

// Canvas setup
const canvas = document.getElementById('gameCanvas') || document.createElement('canvas');
canvas.width = 800;
canvas.height = 600;
document.body.appendChild(canvas);
const ctx = canvas.getContext('2d');

// Game variables
let score = 0;
let gameOver = false;
let gameWon = false;
const breadcrumbsToWin = 20;

// Duck properties
const duck = {
  x: 400,
  y: 300,
  width: 40,
  height: 40,
  speed: 5,
  color: '#FFCC00'
};

// Breadcrumbs array
const breadcrumbs = [];
for (let i = 0; i < 10; i++) {
  breadcrumbs.push({
    x: Math.random() * (canvas.width - 20),
    y: Math.random() * (canvas.height - 20),
    width: 15,
    height: 15,
    color: '#A0522D'
  });
}

// Guards array
const guards = [];
for (let i = 0; i < 3; i++) {
  guards.push({
    x: Math.random() * (canvas.width - 40),
    y: Math.random() * (canvas.height - 40),
    width: 40,
    height: 40,
    speedX: (Math.random() * 2) + 1,
    speedY: (Math.random() * 2) + 1,
    color: '#FF0000'
  });
}

// Handle keyboard input
const keys = {};
window.addEventListener('keydown', (e) => {
  keys[e.key] = true;
});
window.addEventListener('keydown', (e) => {
  // Restart game if game over and Enter key is pressed
  if ((gameOver || gameWon) && e.key === 'Enter') {
    resetGame();
  }
});
window.addEventListener('keyup', (e) => {
  keys[e.key] = false;
});

// Move duck based on keyboard input
function moveDuck() {
  if (keys['ArrowUp'] && duck.y > 0) duck.y -= duck.speed;
  if (keys['ArrowDown'] && duck.y < canvas.height - duck.height) duck.y += duck.speed;
  if (keys['ArrowLeft'] && duck.x > 0) duck.x -= duck.speed;
  if (keys['ArrowRight'] && duck.x < canvas.width - duck.width) duck.x += duck.speed;
}

// Move guards and handle collisions
function moveGuards() {
  guards.forEach(guard => {
    // Move guard
    guard.x += guard.speedX;
    guard.y += guard.speedY;
    
    // Bounce off walls
    if (guard.x <= 0 || guard.x + guard.width >= canvas.width) {
      guard.speedX *= -1;
    }
    if (guard.y <= 0 || guard.y + guard.height >= canvas.height) {
      guard.speedY *= -1;
    }
    
    // Check collision with duck
    if (isColliding(duck, guard)) {
      gameOver = true;
    }
  });
}

// Check if duck collects breadcrumbs
function collectBreadcrumbs() {
  for (let i = breadcrumbs.length - 1; i >= 0; i--) {
    if (isColliding(duck, breadcrumbs[i])) {
      breadcrumbs.splice(i, 1);
      score++;
      
      // Add a new breadcrumb
      breadcrumbs.push({
        x: Math.random() * (canvas.width - 20),
        y: Math.random() * (canvas.height - 20),
        width: 15,
        height: 15,
        color: '#A0522D'
      });
      
      // Check win condition
      if (score >= breadcrumbsToWin) {
        gameWon = true;
      }
    }
  }
}

// Check collision between two objects
function isColliding(obj1, obj2) {
  return obj1.x < obj2.x + obj2.width &&
         obj1.x + obj1.width > obj2.x &&
         obj1.y < obj2.y + obj2.height &&
         obj1.y + obj1.height > obj2.y;
}

// Draw functions
function drawDuck() {
  ctx.fillStyle = duck.color;
  ctx.beginPath();
  ctx.ellipse(duck.x + duck.width/2, duck.y + duck.height/2, duck.width/2, duck.height/2, 0, 0, Math.PI * 2);
  ctx.fill();
  
  // Draw beak
  ctx.fillStyle = '#FF6600';
  ctx.beginPath();
  ctx.moveTo(duck.x + duck.width, duck.y + duck.height/2);
  ctx.lineTo(duck.x + duck.width + 20, duck.y + duck.height/2);
  ctx.lineTo(duck.x + duck.width, duck.y + duck.height/2 + 10);
  ctx.fill();
}

function drawBreadcrumbs() {
  breadcrumbs.forEach(breadcrumb => {
    ctx.fillStyle = breadcrumb.color;
    ctx.fillRect(breadcrumb.x, breadcrumb.y, breadcrumb.width, breadcrumb.height);
  });
}

function drawGuards() {
  guards.forEach(guard => {
    ctx.fillStyle = guard.color;
    ctx.fillRect(guard.x, guard.y, guard.width, guard.height);
  });
}

function drawScore() {
  ctx.fillStyle = '#000000';
  ctx.font = '20px Arial';
  ctx.fillText(`Breadcrumbs: ${score}/${breadcrumbsToWin}`, 20, 30);
}

// Game state functions
function drawGameOver() {
  ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  ctx.fillStyle = '#FFFFFF';
  ctx.font = '40px Arial';
  ctx.textAlign = 'center';
  ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2);
  
  ctx.font = '20px Arial';
  ctx.fillText(`Score: ${score}`, canvas.width / 2, canvas.height / 2 + 40);
  ctx.fillText('Press Enter to play again', canvas.width / 2, canvas.height / 2 + 80);
}

function drawGameWon() {
  ctx.fillStyle = 'rgba(0, 0, 255, 0.7)';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  ctx.fillStyle = '#FFFFFF';
  ctx.font = '40px Arial';
  ctx.textAlign = 'center';
  ctx.fillText('YOU WIN!', canvas.width / 2, canvas.height / 2);
  
  ctx.font = '20px Arial';
  ctx.fillText(`You collected ${score} breadcrumbs!`, canvas.width / 2, canvas.height / 2 + 40);
  ctx.fillText('Press Enter to play again', canvas.width / 2, canvas.height / 2 + 80);
}

function resetGame() {
  score = 0;
  gameOver = false;
  gameWon = false;
  
  duck.x = 400;
  duck.y = 300;
  
  // Reset breadcrumbs
  breadcrumbs.length = 0;
  for (let i = 0; i < 10; i++) {
    breadcrumbs.push({
      x: Math.random() * (canvas.width - 20),
      y: Math.random() * (canvas.height - 20),
      width: 15,
      height: 15,
      color: '#A0522D'
    });
  }
  
  // Reset guards
  guards.length = 0;
  for (let i = 0; i < 3; i++) {
    guards.push({
      x: Math.random() * (canvas.width - 40),
      y: Math.random() * (canvas.height - 40),
      width: 40,
      height: 40,
      speedX: (Math.random() * 2) + 1,
      speedY: (Math.random() * 2) + 1,
      color: '#FF0000'
    });
  }
}

// Main game loop
function gameLoop() {
  // Clear canvas
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  if (!gameOver && !gameWon) {
    // Update game state
    moveDuck();
    moveGuards();
    collectBreadcrumbs();
    
    // Draw everything
    drawBreadcrumbs();
    drawDuck();
    drawGuards();
    drawScore();
  } else if (gameOver) {
    drawGameOver();
  } else if (gameWon) {
    drawGameWon();
  }
  
  // Continue game loop
  requestAnimationFrame(gameLoop);
}

// Start the game
gameLoop();

 Find the guard initialization code and reduce vision range
guards = [
    { x: 700, y: 500, width: 40, height: 40, speed: 3, canSeePlayer: false, visionRange: 120 }, // Reduced from 150
    { x: 100, y: 500, width: 40, height: 40, speed: 3.5, canSeePlayer: false, visionRange: 130 }, // Reduced from 170
    { x: 400, y: 100, width: 40, height: 40, speed: 3.2, canSeePlayer: false, visionRange: 125 } // Reduced from 160
];

// Improve the canSeePlayer function to properly handle hiding behind obstacles
function canSeePlayer(guard) {
    const dx = duck.x + (duck.width / 2) - (guard.x + (guard.width / 2));
    const dy = duck.y + (duck.height / 2) - (guard.y + (guard.height / 2));
    const distance = Math.sqrt(dx * dx + dy * dy);
    
    // Check if player is within vision range
    if (distance <= guard.visionRange) {
        // Improved line of sight check using ray casting
        const steps = 10; // Number of points to check along the line
        for (let i = 1; i <= steps; i++) {
            const checkX = guard.x + (guard.width / 2) + (dx * i / steps);
            const checkY = guard.y + (guard.height / 2) + (dy * i / steps);
            
            // Check if this point intersects with any obstacle
            const intersectsObstacle = obstacles.some(obstacle => 
                checkX >= obstacle.x && 
                checkX <= obstacle.x + obstacle.width && 
                checkY >= obstacle.y && 
                checkY <= obstacle.y + obstacle.height
            );
            
            if (intersectsObstacle) {
                // Vision is blocked by an obstacle
                return false;
            }
        }
        return true; // No obstacles blocking line of sight
    }
    return false;
}

// Enhance the drawObstacles function for better-looking barriers
function drawObstacles() {
    obstacles.forEach((obstacle, index) => {
        // Create more interesting obstacle designs
        // Different types of obstacles with unique appearances
        const type = obstacle.type || (index % 3);
        
        switch(type) {
            case 0: // Wooden crate
                // Base box
                ctx.fillStyle = "#8B4513";
                ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                
                // Wood grain
                ctx.strokeStyle = "#5D2906";
                ctx.lineWidth = 2;
                
                // Horizontal planks
                const plankHeight = obstacle.height / 3;
                for (let i = 0; i < 3; i++) {
                    ctx.strokeRect(
                        obstacle.x, 
                        obstacle.y + i * plankHeight, 
                        obstacle.width, 
                        plankHeight
                    );
                }
                
                // Nails
                ctx.fillStyle = "#A9A9A9";
                const nailPositions = [
                    {x: obstacle.x + 10, y: obstacle.y + 5},
                    {x: obstacle.x + obstacle.width - 10, y: obstacle.y + 5},
                    {x: obstacle.x + 10, y: obstacle.y + obstacle.height - 5},
                    {x: obstacle.x + obstacle.width - 10, y: obstacle.y + obstacle.height - 5}
                ];
                
                nailPositions.forEach(pos => {
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, 2, 0, Math.PI * 2);
                    ctx.fill();
                });
                break;
                
            case 1: // Stone wall
                // Base rectangle
                ctx.fillStyle = "#808080";
                ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                
                // Stone pattern
                const stoneSize = 10;
                ctx.strokeStyle = "#696969";
                ctx.lineWidth = 1;
                
                for (let x = 0; x < obstacle.width; x += stoneSize) {
                    for (let y = 0; y < obstacle.height; y += stoneSize) {
                        // Random offset for natural look
                        const offsetX = Math.random() * 2;
                        const offsetY = Math.random() * 2;
                        
                        // Draw stone
                        ctx.fillStyle = `rgb(${120 + Math.random() * 30}, ${120 + Math.random() * 30}, ${120 + Math.random() * 30})`;
                        ctx.fillRect(
                            obstacle.x + x + offsetX, 
                            obstacle.y + y + offsetY, 
                            stoneSize - 1, 
                            stoneSize - 1
                        );
                    }
                }
                break;
                
            case 2: // Metal barrier
                // Base rectangle
                ctx.fillStyle = "#515151";
                ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                
                // Metallic look
                ctx.fillStyle = "#626262";
                ctx.fillRect(obstacle.x + 3, obstacle.y + 3, obstacle.width - 6, obstacle.height - 6);
                
                // Rivets
                ctx.fillStyle = "#7D7D7D";
                const rivetSize = 4;
                const rivetOffset = 5;
                
                // Corner rivets
                [
                    {x: rivetOffset, y: rivetOffset},
                    {x: obstacle.width - rivetOffset - rivetSize, y: rivetOffset},
                    {x: rivetOffset, y: obstacle.height - rivetOffset - rivetSize},
                    {x: obstacle.width - rivetOffset - rivetSize, y: obstacle.height - rivetOffset - rivetSize}
                ].forEach(pos => {
                    ctx.fillRect(
                        obstacle.x + pos.x, 
                        obstacle.y + pos.y, 
                        rivetSize, 
                        rivetSize
                    );
                });
                
                // Highlight
                ctx.strokeStyle = "#AAAAAA";
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(obstacle.x + 2, obstacle.y + 2);
                ctx.lineTo(obstacle.x + obstacle.width - 2, obstacle.y + 2);
                ctx.stroke();
                break;
        }
        
        // Add shadow for all obstacles
        ctx.fillStyle = "rgba(0, 0, 0, 0.3)";
        ctx.fillRect(obstacle.x + 5, obstacle.y + obstacle.height, obstacle.width, 5);
    });
}

// Add a stealth indicator when duck is hidden
function drawDuck() {
    const isHidden = !guards.some(guard => guard.canSeePlayer);
    
    if (useDuckImage && duckImg.complete) {
        // Adjust transparency when hidden
        ctx.globalAlpha = isHidden ? 0.7 : 1;
        ctx.drawImage(duckImg, duck.x, duck.y, duck.width, duck.height);
        ctx.globalAlpha = 1;
    } else {
        ctx.fillStyle = isHidden ? "rgba(255, 255, 0, 0.7)" : "yellow";
        ctx.fillRect(duck.x, duck.y, duck.width, duck.height);
    }
    
    // Add stealth indicator
    if (isHidden) {
        ctx.fillStyle = "rgba(100, 255, 100, 0.7)";
        ctx.beginPath();
        ctx.arc(duck.x + duck.width - 5, duck.y + 5, 5, 0, Math.PI * 2);
        ctx.fill();
    }
}

// Add power-ups to the game
let powerUps = [];

function initializePowerUps() {
    powerUps = [
        { 
            x: 200, 
            y: 150, 
            width: 25, 
            height: 25, 
            type: "speed", 
            active: false, 
            duration: 7, // seconds
            timeLeft: 0 
        },
        { 
            x: 600, 
            y: 400, 
            width: 25, 
            height: 25, 
            type: "invisible", 
            active: false, 
            duration: 5, // seconds
            timeLeft: 0 
        }
    ];
    
    // Reposition power-ups to valid locations
    powerUps.forEach(powerUp => {
        const validPos = getValidPosition(powerUp);
        powerUp.x = validPos.x;
        powerUp.y = validPos.y;
    });
}

function drawPowerUps() {
    powerUps.forEach(powerUp => {
        if (!powerUp.active) {
            ctx.save();
            
            // Add pulsing effect
            const pulse = 1 + 0.1 * Math.sin(Date.now() / 200);
            
            // Draw power-up based on type
            if (powerUp.type === "speed") {
                // Speed boost - lightning bolt
                ctx.fillStyle = "#FFD700";
                ctx.beginPath();
                ctx.arc(powerUp.x + powerUp.width/2, powerUp.y + powerUp.height/2, 
                      powerUp.width/2 * pulse, 0, Math.PI * 2);
                ctx.fill();
                
                // Lightning symbol
                ctx.fillStyle = "#FFF";
                ctx.beginPath();
                ctx.moveTo(powerUp.x + 10, powerUp.y + 5);
                ctx.lineTo(powerUp.x + 15, powerUp.y + 12);
                ctx.lineTo(powerUp.x + 11, powerUp.y + 13);
                ctx.lineTo(powerUp.x + 16, powerUp.y + 22);
                ctx.lineTo(powerUp.x + 17, powerUp.y + 19);
                ctx.lineTo(powerUp.x + 20, powerUp.y + 19);
                ctx.lineTo(powerUp.x + 10, powerUp.y + 5);
                ctx.fill();
            } else if (powerUp.type === "invisible") {
                // Invisibility - eye symbol
                ctx.fillStyle = "#9370DB";
                ctx.beginPath();
                ctx.arc(powerUp.x + powerUp.width/2, powerUp.y + powerUp.height/2, 
                      powerUp.width/2 * pulse, 0, Math.PI * 2);
                ctx.fill();
                
                // Eye symbol
                ctx.fillStyle = "#FFF";
                ctx.beginPath();
                ctx.ellipse(
                    powerUp.x + powerUp.width/2, 
                    powerUp.y + powerUp.height/2,
                    8, 5, 0, 0, Math.PI * 2
                );
                ctx.fill();
                
                ctx.fillStyle = "#000";
                ctx.beginPath();
                ctx.arc(
                    powerUp.x + powerUp.width/2, 
                    powerUp.y + powerUp.height/2,
                    3, 0, Math.PI * 2
                );
                ctx.fill();
            }
            
            ctx.restore();
        }
    });
}

function handlePowerUpCollisions() {
    powerUps.forEach(powerUp => {
        if (!powerUp.active && checkCollision(duck, powerUp)) {
            // Activate power-up
            powerUp.active = true;
            powerUp.timeLeft = powerUp.duration;
            
            // Apply power-up effect
            if (powerUp.type === "speed") {
                duck.originalSpeed = duck.speed;
                duck.speed = duck.speed * 1.6;
            } else if (powerUp.type === "invisible") {
                duck.isInvisible = true;
            }
            
            // Start countdown timer
            const powerUpInterval = setInterval(() => {
                if (gameOver || powerUp.timeLeft <= 0) {
                    // Deactivate power-up
                    if (powerUp.type === "speed") {
                        duck.speed = duck.originalSpeed;
                    } else if (powerUp.type === "invisible") {
                        duck.isInvisible = false;
                    }
                    
                    // Reset power-up
                    powerUp.active = false;
                    const validPos = getValidPosition(powerUp);
                    powerUp.x = validPos.x;
                    powerUp.y = validPos.y;
                    
                    clearInterval(powerUpInterval);
                } else {
                    powerUp.timeLeft--;
                }
            }, 1000);
        }
    });
}

// Update the canSeePlayer function to respect invisibility power-up
function canSeePlayer(guard) {
    // If duck has invisibility power-up, guards can't see
    if (duck.isInvisible) return false;
    
    const dx = duck.x + (duck.width / 2) - (guard.x + (guard.width / 2));
    const dy = duck.y + (duck.height / 2) - (guard.y + (guard.height / 2));
    const distance = Math.sqrt(dx * dx + dy * dy);
    
    // Rest of the function remains the same
    // ...
}

// Update the updateGame function to include power-ups
function updateGame() {
    if (gameOver) return;
    ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
    
    drawBackground();
    handleMovement();
    moveGuards();
    handleCollisions();
    handlePowerUpCollisions(); // Add this line
    
    drawObstacles();
    drawBread();
    drawPowerUps(); // Add this line
    drawGuards();
    drawDuck();
    drawGameInfo();
    drawPowerUpStatus(); // Add this line
}

// Draw power-up status indicators
function drawPowerUpStatus() {
    let y = 80; // Starting y position
    
    powerUps.forEach(powerUp => {
        if (powerUp.active) {
            // Draw power-up status
            ctx.fillStyle = "white";
            ctx.font = "bold 16px Arial";
            
            if (powerUp.type === "speed") {
                ctx.fillText(`Speed Boost: ${powerUp.timeLeft}s`, 20, y);
                // Draw small icon
                ctx.fillStyle = "#FFD700";
                ctx.beginPath();
                ctx.moveTo(150, y - 5);
                ctx.lineTo(155, y - 10);
                ctx.lineTo(151, y - 11);
                ctx.lineTo(156, y);
                ctx.lineTo(157, y - 3);
                ctx.lineTo(160, y - 3);
                ctx.lineTo(150, y - 5);
                ctx.fill();
            } else if (powerUp.type === "invisible") {
                ctx.fillText(`Invisibility: ${powerUp.timeLeft}s`, 20, y);
                // Draw small icon
                ctx.fillStyle = "#9370DB";
                ctx.beginPath();
                ctx.arc(155, y - 5, 5, 0, Math.PI * 2);
                ctx.fill();
            }
            
            y += 25; // Increment y position for next status
        }
    });
}

// Initialize power-ups at game start
function initializeGame() {
    bread = getValidPosition(bread);
    obstacles = [
        { x: 400, y: 200, width: 50, height: 50, type: 0 },
        { x: 200, y: 400, width: 80, height: 30, type: 1 },
        { x: 600, y: 100, width: 60, height: 60, type: 2 },
        { x: 300, y: 300, width: 40, height: 70, type: 0 },
        { x: 700, y: 300, width: 30, height: 100, type: 1 }
    ];
    guards = [
        { x: 700, y: 500, width: 40, height: 40, speed: 3, canSeePlayer: false, visionRange: 120 },
        { x: 100, y: 500, width: 40, height: 40, speed: 3.5, canSeePlayer: false, visionRange: 130 },
        { x: 400, y: 100, width: 40, height: 40, speed: 3.2, canSeePlayer: false, visionRange: 125 }
    ];
    initializePowerUps(); // Add this line
}

// Update the CSS to include a better game styling
// Add this to your style section:
/*
#duck-heist-game {
    position: relative;
    width: 100%;
    max-width: 800px;
    max-height: 100vh;
    box-shadow: 0 10px 25px rgba(0, 0, 0, 0.7);
    border-radius: 10px;
    overflow: hidden;
}

canvas {
    border: 4px solid #222;
    border-radius: 8px;
    box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
    width: 100%;
    height: auto;
    display: block;
    margin: 0 auto;
}

#restart-btn {
    padding: 12px 24px;
    font-size: 20px;
    background-color: #ffcc00;
    color: #333;
    border: none;
    border-radius: 6px;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
    font-weight: bold;
    transition: all 0.2s ease;
}

#restart-btn:hover {
    background-color: #ffdd33;
    transform: translateY(-2px);
    box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
}
*/

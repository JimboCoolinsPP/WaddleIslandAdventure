<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Keep existing meta tags and title -->
    <style>
        /* Add this to your CSS */
        #duck {
            left: 25%; /* Add initial horizontal position */
        }
        .pipe {
            width: 12vmin;
            position: absolute;
            left: 100%; /* Start pipes off-screen */
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <!-- Keep existing elements -->
    </div>

    <script>
        // Modified Game Initialization
        const gameContainer = document.getElementById('gameContainer');
        const duck = document.createElement('div');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const startScreen = document.getElementById('startScreen');

        // Set initial duck position
        duck.id = 'duck';
        duck.style.position = 'absolute';
        gameContainer.appendChild(duck);

        // Game State Variables
        let containerWidth, containerHeight;
        let duckY = 0;
        let velocity = 0;
        let gravity = 0;
        let isGameStarted = false;
        let score = 0;
        let pipes = [];
        let coins = [];
        let gameSpeed = 0;
        let lastFrameTime = 0;

        function initGame() {
            // Set container dimensions
            containerWidth = gameContainer.clientWidth;
            containerHeight = gameContainer.clientHeight;
            
            // Reset physics values
            gravity = containerHeight * 0.0015;
            gameSpeed = containerWidth * 0.0075;
            
            // Set initial duck position
            duckY = containerHeight / 2;
            duck.style.top = `${duckY}px`;
            duck.style.left = '25%';
        }

        // Modified createPipe function
        function createPipe() {
            const gapHeight = containerHeight * 0.25;
            const minTopPosition = containerHeight * 0.15;
            const maxTopPosition = containerHeight * 0.65 - gapHeight;
            const gapTop = Math.random() * (maxTopPosition - minTopPosition) + minTopPosition;

            // Create pipes
            const topPipe = document.createElement('div');
            topPipe.classList.add('pipe', 'pipe-top');
            topPipe.style.height = `${gapTop}px`;
            
            const bottomPipe = document.createElement('div');
            bottomPipe.classList.add('pipe', 'pipe-bottom');
            bottomPipe.style.height = `${containerHeight - (gapTop + gapHeight)}px`;

            gameContainer.append(topPipe, bottomPipe);

            // Create coin
            const coin = document.createElement('div');
            coin.classList.add('coin');
            coin.style.top = `${gapTop + gapHeight / 2}px`;
            gameContainer.appendChild(coin);

            pipes.push({
                top: topPipe,
                bottom: bottomPipe,
                x: containerWidth,
                coin: coin,
                collected: false
            });
        }

        // Revised game loop with delta timing
        function gameLoop(timestamp) {
            if (!isGameStarted) return;

            const deltaTime = timestamp - lastFrameTime;
            lastFrameTime = timestamp;

            // Update physics
            velocity += gravity * (deltaTime / 16);
            duckY += velocity * (deltaTime / 16);
            duck.style.top = `${Math.max(0, Math.min(duckY, containerHeight - duck.clientHeight))}px`;

            // Move pipes and coins
            pipes.forEach(pipe => {
                pipe.x -= gameSpeed * (deltaTime / 16);
                pipe.top.style.left = `${pipe.x}px`;
                pipe.bottom.style.left = `${pipe.x}px`;
                pipe.coin.style.left = `${pipe.x + containerWidth * 0.15}px`;

                // Remove off-screen elements
                if (pipe.x < -pipe.top.clientWidth) {
                    pipe.top.remove();
                    pipe.bottom.remove();
                    pipe.coin.remove();
                }
            });

            checkCollisions();
            requestAnimationFrame(gameLoop);
        }

        // Improved collision detection
        function checkCollisions() {
            const duckRect = duck.getBoundingClientRect();

            pipes.forEach(pipe => {
                if (pipe.x < -pipe.top.clientWidth) return;

                const topPipeRect = pipe.top.getBoundingClientRect();
                const bottomPipeRect = pipe.bottom.getBoundingClientRect();
                const coinRect = pipe.coin.getBoundingClientRect();

                // Pipe collision
                if (elementsOverlap(duckRect, topPipeRect) || 
                   elementsOverlap(duckRect, bottomPipeRect)) {
                    gameOver();
                }

                // Coin collection
                if (!pipe.collected && elementsOverlap(duckRect, coinRect)) {
                    pipe.collected = true;
                    score += 10;
                    scoreDisplay.textContent = `Score: ${score}`;
                    pipe.coin.style.opacity = '0';
                }
            });
        }

        function elementsOverlap(rect1, rect2) {
            return !(rect1.right < rect2.left || 
                    rect1.left > rect2.right || 
                    rect1.bottom < rect2.top || 
                    rect1.top > rect2.bottom);
        }

        // Modified startGame function
        function startGame() {
            initGame();
            isGameStarted = true;
            startScreen.style.display = 'none';
            
            // Clear existing elements
            pipes.forEach(pipe => {
                pipe.top.remove();
                pipe.bottom.remove();
                pipe.coin.remove();
            });
            pipes = [];

            // Start pipe generation
            const pipeInterval = setInterval(() => {
                if (isGameStarted) createPipe();
                else clearInterval(pipeInterval);
            }, 2000);

            lastFrameTime = performance.now();
            requestAnimationFrame(gameLoop);
        }

        // Keep rest of your code but add:
        // Initialize game on first click
        function handleFirstClick() {
            if (!isGameStarted) {
                startGame();
                // Remove this event listener after first click
                gameContainer.removeEventListener('click', handleFirstClick);
            }
        }

        // Initialize event listeners
        gameContainer.addEventListener('click', handleFirstClick);
        gameContainer.addEventListener('touchstart', handleFirstClick);
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') handleFirstClick();
        });

        // Initial setup
        initGame();
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Waddle Island Adventures - Mobile Game</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      touch-action: none;
      overflow: hidden;
      position: fixed;
      width: 100%;
      height: 100%;
      background-color: #4caf50;
      font-family: Arial, sans-serif;
    }
    
    #game-container {
      position: relative;
      width: 100%;
      height: 100%;
      overflow: hidden;
    }
    
    #game-canvas {
      display: block;
      width: 100%;
      height: 100%;
      background-color: #87CEEB;
    }
    
    #start-screen, #game-over {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      background-color: rgba(0, 0, 0, 0.7);
      color: white;
      z-index: 10;
    }
    
    .hidden {
      display: none !important;
    }
    
    button {
      padding: 15px 30px;
      font-size: 1.5rem;
      background-color: #4caf50;
      border: none;
      border-radius: 8px;
      color: white;
      margin-top: 20px;
      cursor: pointer;
    }
    
    h1 {
      font-size: 2rem;
      margin-bottom: 20px;
      color: #4caf50;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
    }
    
    #score-display {
      position: absolute;
      top: 20px;
      left: 0;
      width: 100%;
      text-align: center;
      font-size: 2rem;
      color: white;
      z-index: 5;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
    }
    
    @media (orientation: portrait) {
      /* Adjustments for portrait orientation */
      button {
        padding: 20px 40px;
        font-size: 1.8rem;
      }
    }
    
    /* Hide URL bar on iOS */
    html {
      height: 100%;
    }
  </style>
</head>
<body>
  <div id="game-container">
    <canvas id="game-canvas"></canvas>
    <div id="score-display">Score: 0</div>
    
    <div id="start-screen">
      <h1>Waddle Island Adventures</h1>
      <p>Tap anywhere to help Waddle Duck fly!</p>
      <button id="start-button">Start Game</button>
    </div>
    
    <div id="game-over" class="hidden">
      <h1>Game Over!</h1>
      <p>Your score: <span id="final-score">0</span></p>
      <button id="restart-button">Play Again</button>
    </div>
  </div>

  <script>
    // Game variables
    let canvas, ctx;
    let gameStarted = false;
    let gameOver = false;
    let score = 0;
    let lastTime = 0;
    let animationId;
    
    // Duck variables
    const duck = {
      x: 0,
      y: 0,
      width: 50,
      height: 40,
      gravity: 0.5,
      velocity: 0,
      lift: -8,
      img: new Image()
    };
    duck.img.src = 'https://i.imgur.com/2dhXor9.jpeg'; // Use a sprite from your game
    
    // Obstacles array
    let pipes = [];
    const pipeWidth = 80;
    const pipeGap = 150;
    let pipeSpawnTimer = 0;
    const pipeSpawnInterval = 1500; // milliseconds
    
    // Initialize the game
    function init() {
      canvas = document.getElementById('game-canvas');
      ctx = canvas.getContext('2d');
      
      // Set canvas size to match window
      resizeCanvas();
      
      // Center duck initially
      reset();
      
      // Event listeners for mobile and desktop
      document.addEventListener('touchstart', handleJump);
      document.addEventListener('mousedown', handleJump);
      document.addEventListener('keydown', handleKeydown);
      
      document.getElementById('start-button').addEventListener('click', startGame);
      document.getElementById('restart-button').addEventListener('click', restartGame);
      
      // Handle window resize
      window.addEventListener('resize', resizeCanvas);
      
      // Initial draw
      draw();
    }
    
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      
      // Update game elements for new size if needed
      if (gameStarted) {
        // Adjust positions if the game is already running
      }
    }
    
    function reset() {
      duck.x = canvas.width / 4;
      duck.y = canvas.height / 2;
      duck.velocity = 0;
      pipes = [];
      score = 0;
      updateScoreDisplay();
    }
    
    function startGame() {
      document.getElementById('start-screen').classList.add('hidden');
      gameStarted = true;
      gameOver = false;
      reset();
      animate(0);
    }
    
    function restartGame() {
      document.getElementById('game-over').classList.add('hidden');
      gameStarted = true;
      gameOver = false;
      reset();
      animate(0);
    }
    
    function handleJump(e) {
      e.preventDefault(); // Prevent default behavior on mobile
      
      // Start game if not started
      if (!gameStarted && !gameOver) {
        startGame();
        return;
      }
      
      // Jump if game is active
      if (gameStarted && !gameOver) {
        duck.velocity = duck.lift;
      }
    }
    
    function handleKeydown(e) {
      if (e.code === 'Space') {
        e.preventDefault();
        
        if (!gameStarted && !gameOver) {
          startGame();
          return;
        }
        
        if (gameStarted && !gameOver) {
          duck.velocity = duck.lift;
        }
      }
    }
    
    function spawnPipe() {
      const minHeight = 50;
      const maxHeight = canvas.height - pipeGap - minHeight;
      const height = Math.floor(Math.random() * (maxHeight - minHeight + 1)) + minHeight;
      
      pipes.push({
        x: canvas.width,
        topHeight: height,
        bottomY: height + pipeGap,
        passed: false
      });
    }
    
    function updatePipes(deltaTime) {
      // Spawn new pipes based on timer
      pipeSpawnTimer += deltaTime;
      if (pipeSpawnTimer > pipeSpawnInterval) {
        spawnPipe();
        pipeSpawnTimer = 0;
      }
      
      // Update pipe positions
      const speed = 4; // Adjust for difficulty
      for (let i = pipes.length - 1; i >= 0; i--) {
        pipes[i].x -= speed;
        
        // Check if duck passed the pipe
        if (!pipes[i].passed && pipes[i].x + pipeWidth < duck.x) {
          pipes[i].passed = true;
          score++;
          updateScoreDisplay();
        }
        
        // Remove pipes that are off screen
        if (pipes[i].x + pipeWidth < 0) {
          pipes.splice(i, 1);
        }
      }
    }
    
    function updateDuck() {
      // Apply gravity
      duck.velocity += duck.gravity;
      duck.y += duck.velocity;
      
      // Check boundaries
      if (duck.y < 0) {
        duck.y = 0;
        duck.velocity = 0;
      }
      
      if (duck.y + duck.height > canvas.height) {
        endGame();
      }
    }
    
    function checkCollisions() {
      for (const pipe of pipes) {
        // Check collision with top pipe
        if (
          duck.x + duck.width > pipe.x &&
          duck.x < pipe.x + pipeWidth &&
          duck.y < pipe.topHeight
        ) {
          endGame();
        }
        
        // Check collision with bottom pipe
        if (
          duck.x + duck.width > pipe.x &&
          duck.x < pipe.x + pipeWidth &&
          duck.y + duck.height > pipe.bottomY
        ) {
          endGame();
        }
      }
    }
    
    function endGame() {
      gameOver = true;
      gameStarted = false;
      cancelAnimationFrame(animationId);
      
      document.getElementById('final-score').textContent = score;
      document.getElementById('game-over').classList.remove('hidden');
    }
    
    function updateScoreDisplay() {
      document.getElementById('score-display').textContent = `Score: ${score}`;
    }
    
    function draw() {
      // Clear canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Draw background (could be more elaborate)
      ctx.fillStyle = '#87CEEB';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Draw pipes
      ctx.fillStyle = '#4caf50';
      for (const pipe of pipes) {
        // Top pipe
        ctx.fillRect(pipe.x, 0, pipeWidth, pipe.topHeight);
        
        // Bottom pipe
        ctx.fillRect(pipe.x, pipe.bottomY, pipeWidth, canvas.height - pipe.bottomY);
      }
      
      // Draw duck
      if (duck.img.complete) {
        ctx.drawImage(duck.img, duck.x, duck.y, duck.width, duck.height);
      } else {
        // Fallback if image not loaded
        ctx.fillStyle = '#FFFF00';
        ctx.fillRect(duck.x, duck.y, duck.width, duck.height);
      }
    }
    
    function animate(currentTime) {
      const deltaTime = currentTime - lastTime;
      lastTime = currentTime;
      
      if (gameStarted && !gameOver) {
        updateDuck();
        updatePipes(deltaTime);
        checkCollisions();
      }
      
      draw();
      
      if (gameStarted && !gameOver) {
        animationId = requestAnimationFrame(animate);
      }
    }
    
    // Wait for all resources to load before starting
    window.addEventListener('load', init);
    
    // Prevent scrolling on mobile devices
    document.addEventListener('touchmove', function(e) {
      e.preventDefault();
    }, { passive: false });
  </script>
</body>
</html>

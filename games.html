<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Games</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 0;
      background: #222;
      color: white;
      text-align: center;
    }
    header {
      background: #111;
      padding: 20px;
      font-size: 2rem;
    }
    .game-grid {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      padding: 20px;
    }
    .game-item {
      background: #333;
      padding: 10px;
      margin: 10px;
      border-radius: 10px;
      width: 200px;
      text-align: center;
      transition: transform 0.2s;
    }
    .game-item:hover {
      transform: scale(1.05);
    }
    .game-item img {
      width: 100%;
      border-radius: 10px;
    }
    .game-item a {
      display: block;
      color: #4caf50;
      text-decoration: none;
      font-weight: bold;
      margin-top: 10px;
    }
    footer {
      background: #111;
      padding: 10px;
      margin-top: 20px;
    }
  </style>
</head>
<body>
  <header>My Browser Games</header>
  <div class="game-grid">
    <div class="game-item">
      <img src="https://i.imgur.com/example1.png" alt="Duck Heist">
      <a href="game-duckheist.html">Play Duck Heist</a>
    </div>
    <div class="game-item">
      <img src="https://i.imgur.com/example2.png" alt="Quackventure">
      <a href="game-quackventure.html">Play Quackventure</a>
    </div>
  </div>
<div class="game-container">
    <!-- Game title and description -->
    <h2>Flappy Duck Adventure</h2>
    <p>Help the duck navigate through pipes and collect coins. Tap or press SPACE to flap!</p>
    
    <!-- Game area -->
    <div class="game-area">
        <div class="game-ui">
            <div>Coins: <span id="coinCount">0</span></div>
            <div>Score: <span id="scoreCount">0</span></div>
        </div>
        <canvas id="gameCanvas"></canvas>
        <div id="gameButtons">
            <button id="restartButton">Restart</button>
            <button id="pauseButton">Pause</button>
        </div>
        <div id="mobileTapArea"></div>
    </div>
    
    <!-- Game controls/instructions -->
    <div class="game-controls">
        <h3>Controls:</h3>
        <ul>
            <li>SPACE or TAP - Flap Wings</li>
            <li>Pause Button - Pause Game</li>
            <li>Restart Button - Restart Game</li>
        </ul>
    </div>
</div>

<style>
    .game-container {
        width: 100%;
        max-width: 800px;
        margin: 10px auto;
        padding: 10px;
        background: #f0f0f0;
        border-radius: 10px;
        box-shadow: 0 0 10px rgba(0,0,0,0.1);
        box-sizing: border-box;
    }
    
    .game-area {
        position: relative;
        width: 100%;
        height: 0;
        padding-bottom: 75%; /* 4:3 aspect ratio */
        margin: 10px 0;
        border: 3px solid #333;
        border-radius: 5px;
        overflow: hidden;
        background: #87CEEB;
    }
    
    /* Game-specific styles */
    body {
        margin: 0;
        padding: 0;
        font-family: 'Arial', sans-serif;
        touch-action: manipulation; /* Prevents double-tap to zoom on mobile */
    }
    
    canvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
    }
    
    .game-ui {
        position: absolute;
        top: 10px;
        left: 10px;
        background: rgba(0, 0, 0, 0.5);
        color: white;
        padding: 10px;
        border-radius: 5px;
        font-size: 18px;
        display: flex;
        flex-direction: column;
        gap: 5px;
        z-index: 10;
    }
    
    #gameButtons {
        position: absolute;
        top: 10px;
        right: 10px;
        display: flex;
        gap: 10px;
        z-index: 20;
    }
    
    #gameButtons button {
        background: #4CAF50;
        color: white;
        border: none;
        padding: 8px 12px;
        border-radius: 5px;
        cursor: pointer;
        font-size: 16px;
        font-weight: bold;
        box-shadow: 0 2px 5px rgba(0,0,0,0.3);
    }
    
    #gameButtons button:hover {
        background: #45a049;
    }
    
    #mobileTapArea {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 5;
        cursor: pointer;
    }
    
    .game-controls {
        margin-top: 15px;
        padding: 10px;
        background: #e0e0e0;
        border-radius: 5px;
    }
    
    .game-controls ul {
        list-style-type: none;
        padding-left: 10px;
        margin: 10px 0;
    }
    
    .game-controls li {
        margin: 5px 0;
    }
    
    /* Responsive adjustments */
    @media (max-width: 600px) {
        .game-container {
            padding: 5px;
            margin: 5px auto;
        }
        
        .game-area {
            padding-bottom: 150%; /* Taller ratio for mobile */
            border-width: 2px;
        }
        
        .game-ui {
            font-size: 14px;
            padding: 5px;
        }
        
        #gameButtons button {
            padding: 6px 10px;
            font-size: 14px;
        }
        
        h2 {
            font-size: 1.5em;
            margin: 10px 0;
        }
        
        p {
            font-size: 0.9em;
            margin: 5px 0;
        }
    }
</style>

<script>
    // Wait for the DOM to be fully loaded
    document.addEventListener('DOMContentLoaded', function() {
        const canvas = document.getElementById("gameCanvas");
        const ctx = canvas.getContext("2d");
        const coinCountElement = document.getElementById("coinCount");
        const scoreCountElement = document.getElementById("scoreCount");
        const restartButton = document.getElementById("restartButton");
        const pauseButton = document.getElementById("pauseButton");
        const mobileTapArea = document.getElementById("mobileTapArea");
        
        // Set canvas to fill the game area
        function resizeCanvas() {
            const gameArea = canvas.parentElement;
            const rect = gameArea.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;
            
            // If game is already running, redraw everything
            if (gameStarted && !gameOver) {
                drawBackground();
                drawObstacles();
                drawCoins();
                drawDuck();
            } else if (!gameStarted) {
                drawBackground();
                drawStartScreen();
            } else if (gameOver) {
                drawBackground();
                drawObstacles();
                drawCoins();
                drawDuck();
                drawGameOver();
            }
        }
        
        // Game state
let gameStarted = false;
let gamePaused = false;
let gameOver = false;

// Initial canvas sizing
resizeCanvas();
        
        // Duck object (similar to flappy bird)
        let duck = {
            x: 0, // Will be set in initGame based on canvas size
            y: 0, // Will be set in initGame based on canvas size
            width: 0, // Will be set in initGame based on canvas size
            height: 0, // Will be set in initGame based on canvas size
            velocityY: 0,
            gravity: 0,
            flapPower: 0,
            frame: 0,
            frameCount: 0,
            animationSpeed: 5
        };
        
        // Game world
        let obstacles = []; // pipes
        let coins_array = [];
        
        // Pipe generation
        let pipeWidth = 0; // Will be set in initGame based on canvas size
        let pipeGap = 0; // Will be set in initGame based on canvas size
        let pipeSpacing = 0; // Will be set in initGame based on canvas size
        
        // Animation variables
        let animationFrame;
        
        // Calculate game proportions based on canvas size
        function calculateProportions() {
            // Duck size (5-6% of screen height)
            duck.width = Math.floor(canvas.height * 0.06);
            duck.height = Math.floor(canvas.height * 0.05);
            
            // Duck position
            duck.x = Math.floor(canvas.width * 0.25);
            duck.y = Math.floor(canvas.height * 0.5);
            
            // Physics
            duck.gravity = canvas.height * 0.0015;
            duck.flapPower = -canvas.height * 0.012;
            
            // Pipes
            pipeWidth = Math.floor(canvas.width * 0.12);
            pipeGap = Math.floor(canvas.height * 0.30);
            pipeSpacing = Math.floor(canvas.width * 0.5);
        }
        
        // Initialize game
        function initGame() {
            obstacles = [];
            coins_array = [];
            
            // Calculate proportions based on current canvas size
            calculateProportions();
            
            // Reset duck position
            duck.y = canvas.height / 2;
            duck.velocityY = 0;
            
            // Reset score
            score = 0;
            coins = 0;
            
            // Generate initial pipes
            generateInitialPipes();
            
            gameStarted = true;
            gamePaused = false;
            gameOver = false;
            
            // Update UI
            coinCountElement.textContent = coins;
            scoreCountElement.textContent = score;
            
            // Update pause button text
            pauseButton.textContent = "Pause";
        }
        
        // Generate initial pipes
        function generateInitialPipes() {
            // Start pipes off-screen to the right
            let pipeX = canvas.width + 100;
            
            // Generate 3 initial pipe pairs
            for (let i = 0; i < 3; i++) {
                addPipePair(pipeX);
                pipeX += pipeSpacing;
            }
        }
        
        // Add a pair of pipes (top and bottom)
        function addPipePair(x) {
            const gapStart = Math.random() * (canvas.height - pipeGap - 200) + 100;
            
            // Top pipe
            obstacles.push({
                x: x,
                y: 0,
                width: pipeWidth,
                height: gapStart,
                passed: false
            });
            
            // Bottom pipe
            obstacles.push({
                x: x,
                y: gapStart + pipeGap,
                width: pipeWidth,
                height: canvas.height - (gapStart + pipeGap),
                passed: false
            });
            
            // Add coins in the gap
            const coinCount = Math.floor(Math.random() * 3) + 1;
            const coinSpacing = pipeGap / (coinCount + 1);
            const coinSize = Math.floor(canvas.height * 0.05);
            
            for (let i = 0; i < coinCount; i++) {
                coins_array.push({
                    x: x + pipeWidth / 2,
                    y: gapStart + (i + 1) * coinSpacing,
                    width: coinSize,
                    height: coinSize,
                    collected: false
                });
            }
        }
        
        // Draw duck with animation
        function drawDuck() {
            ctx.save();
            
            // Update animation frame
            duck.frameCount++;
            if (duck.frameCount >= duck.animationSpeed) {
                duck.frame = (duck.frame + 1) % 2; // 2 frames of animation
                duck.frameCount = 0;
            }
            
            // Rotation based on velocity
            const rotation = Math.min(Math.PI/4, Math.max(-Math.PI/4, duck.velocityY * 0.05));
            
            ctx.translate(duck.x, duck.y);
            ctx.rotate(rotation);
            
            // Draw duck body
            ctx.fillStyle = "yellow";
            ctx.beginPath();
            ctx.ellipse(0, 0, duck.width / 2, duck.height / 2, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw duck wings
            ctx.fillStyle = "#E5C601";
            if (duck.velocityY < 0) {
                // Flapping up
                ctx.beginPath();
                ctx.ellipse(-duck.width / 3, 0, duck.width / 3, duck.height / 4, Math.PI / 4, 0, Math.PI * 2);
                ctx.fill();
            } else {
                // Flapping down
                ctx.beginPath();
                ctx.ellipse(-duck.width / 3, duck.height / 5, duck.width / 3, duck.height / 4, -Math.PI / 4, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Draw duck head
            ctx.fillStyle = "yellow";
            ctx.beginPath();
            ctx.arc(duck.width / 3, -duck.height / 10, duck.width / 3, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw duck beak
            ctx.fillStyle = "orange";
            ctx.beginPath();
            ctx.moveTo(duck.width / 2, -duck.height / 10);
            ctx.lineTo(duck.width * 0.8, 0);
            ctx.lineTo(duck.width / 2, duck.height / 10);
            ctx.fill();
            
            // Draw duck eye
            ctx.fillStyle = "black";
            ctx.beginPath();
            ctx.arc(duck.width / 2, -duck.height / 5, duck.width / 15, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.restore();
        }
        
        // Draw pipes (obstacles)
        function drawObstacles() {
            obstacles.forEach(pipe => {
                // Green pipes with darker borders
                ctx.fillStyle = "#2E8B57"; // Sea green
                ctx.fillRect(pipe.x, pipe.y, pipe.width, pipe.height);
                
                // Pipe border
                ctx.strokeStyle = "#1C542D";
                ctx.lineWidth = Math.max(2, Math.floor(canvas.width * 0.005));
                ctx.strokeRect(pipe.x, pipe.y, pipe.width, pipe.height);
                
                // Pipe cap
                ctx.fillStyle = "#3CB371"; // Medium sea green
                const capHeight = Math.floor(canvas.height * 0.04);
                const capWidth = Math.floor(canvas.width * 0.02);
                
                if (pipe.y === 0) {
                    // Top pipe cap
                    ctx.fillRect(pipe.x - capWidth/2, pipe.height - capHeight, pipe.width + capWidth, capHeight);
                    ctx.strokeRect(pipe.x - capWidth/2, pipe.height - capHeight, pipe.width + capWidth, capHeight);
                } else {
                    // Bottom pipe cap
                    ctx.fillRect(pipe.x - capWidth/2, pipe.y, pipe.width + capWidth, capHeight);
                    ctx.strokeRect(pipe.x - capWidth/2, pipe.y, pipe.width + capWidth, capHeight);
                }
            });
        }
        
        // Draw coins
        function drawCoins() {
            coins_array.forEach(coin => {
                if (!coin.collected) {
                    // Coin body
                    ctx.fillStyle = "gold";
                    ctx.beginPath();
                    ctx.arc(coin.x, coin.y, coin.width/2, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Coin border
                    ctx.strokeStyle = "#DAA520"; // Golden rod
                    ctx.lineWidth = Math.max(1, Math.floor(canvas.width * 0.003));
                    ctx.stroke();
                    
                    // Shine effect
                    ctx.fillStyle = "white";
                    ctx.beginPath();
                    ctx.arc(coin.x - coin.width/6, coin.y - coin.width/6, coin.width/6, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Dollar sign
                    const fontSize = Math.max(10, Math.floor(coin.width * 0.7));
                    ctx.fillStyle = "#DAA520";
                    ctx.font = `${fontSize}px Arial`;
                    ctx.textAlign = "center";
                    ctx.textBaseline = "middle";
                    ctx.fillText("$", coin.x, coin.y);
                }
            });
        }
        
        // Draw background
        function drawBackground() {
            // Sky gradient
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, "#87CEEB"); // Sky blue
            gradient.addColorStop(1, "#1E90FF"); // Dodger blue
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Sun
            const sunRadius = Math.floor(canvas.width * 0.07);
            ctx.fillStyle = "#FFD700";
            ctx.beginPath();
            ctx.arc(sunRadius + 20, sunRadius + 20, sunRadius, 0, Math.PI * 2);
            ctx.fill();
            
            // Clouds - positioned based on canvas size
            ctx.fillStyle = "white";
            drawCloud(canvas.width * 0.3, canvas.height * 0.15, canvas.width * 0.15, canvas.height * 0.08);
            drawCloud(canvas.width * 0.6, canvas.height * 0.25, canvas.width * 0.2, canvas.height * 0.1);
            drawCloud(canvas.width * 0.15, canvas.height * 0.35, canvas.width * 0.18, canvas.height * 0.09);
            
            // Ground
            const groundHeight = Math.floor(canvas.height * 0.04);
            ctx.fillStyle = "#8B4513"; // Brown
            ctx.fillRect(0, canvas.height - groundHeight, canvas.width, groundHeight);
            
            // Grass on ground
            const grassSpacing = Math.max(5, Math.floor(canvas.width * 0.015));
            const grassHeight = Math.floor(canvas.height * 0.02);
            for (let i = 0; i < canvas.width; i += grassSpacing) {
                ctx.fillStyle = "#228B22"; // Forest green
                ctx.beginPath();
                ctx.moveTo(i, canvas.height - groundHeight);
                ctx.lineTo(i + grassSpacing/2, canvas.height - groundHeight - grassHeight);
                ctx.lineTo(i + grassSpacing, canvas.height - groundHeight);
                ctx.fill();
            }
        }
        
        // Helper function to draw a fluffy cloud
        function drawCloud(x, y, width, height) {
            ctx.beginPath();
            ctx.arc(x + width * 0.3, y + height * 0.5, height * 0.5, 0, Math.PI * 2);
            ctx.arc(x + width * 0.5, y + height * 0.3, height * 0.6, 0, Math.PI * 2);
            ctx.arc(x + width * 0.7, y + height * 0.5, height * 0.5, 0, Math.PI * 2);
            ctx.arc(x + width * 0.5, y + height * 0.7, height * 0.4, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // Check collision with obstacles (pipes)
        function checkObstacleCollisions() {
            // Check collision with each pipe
            for (let pipe of obstacles) {
                if (
                    duck.x + duck.width / 3 > pipe.x &&
                    duck.x - duck.width / 3 < pipe.x + pipe.width &&
                    duck.y + duck.height / 3 > pipe.y &&
                    duck.y - duck.height / 3 < pipe.y + pipe.height
                ) {
                    // Collision detected
                    return true;
                }
                
                // Check if pipe has been passed
                if (!pipe.passed && pipe.x + pipe.width < duck.x - duck.width / 2) {
                    pipe.passed = true;
                    // Only increment score once per pipe pair (every other pipe)
                    if (obstacles.indexOf(pipe) % 2 === 0) {
                        score++;
                        scoreCountElement.textContent = score;
                    }
                }
            }
            
            // Check collision with ceiling or floor
            if (duck.y - duck.height / 2 < 0 || duck.y + duck.height / 2 > canvas.height) {
                return true;
            }
            
            return false;
        }
        
        // Check collision with coins
        function checkCoinCollisions() {
            coins_array.forEach(coin => {
                if (
                    !coin.collected &&
                    Math.sqrt(
                        Math.pow(duck.x - coin.x, 2) + 
                        Math.pow(duck.y - coin.y, 2)
                    ) < (duck.width / 3 + coin.width / 2)
                ) {
                    coin.collected = true;
                    coins++;
                    coinCountElement.textContent = coins;
                }
            });
        }
        
        // Update game state
        function update() {
            if (!gameStarted || gamePaused || gameOver) return;
            
            // Apply gravity
            duck.velocityY += duck.gravity;
            duck.y += duck.velocityY;
            
            // Calculate game speed based on canvas width for consistent experience
            const gameSpeed = canvas.width * 0.003;
            
            // Update obstacles (move pipes left)
            obstacles.forEach(pipe => {
                pipe.x -= gameSpeed;
            });
            
            // Update coins (move with pipes)
            coins_array.forEach(coin => {
                coin.x -= gameSpeed;
            });
            
            // Generate new pipes if needed
            if (obstacles.length > 0 && obstacles[obstacles.length - 2].x < canvas.width - pipeSpacing) {
                addPipePair(canvas.width + pipeWidth);
            }
            
            // Remove pipes that are off-screen
            obstacles = obstacles.filter(pipe => pipe.x + pipe.width > 0);
            
            // Remove collected coins or coins off-screen
            coins_array = coins_array.filter(coin => !coin.collected && coin.x + coin.width > 0);
            
            // Check collisions
            if (checkObstacleCollisions()) {
                gameOver = true;
            }
            
            checkCoinCollisions();
        }
        
        // Draw game over screen
        function drawGameOver() {
            ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            const fontSize = Math.max(20, Math.floor(canvas.width * 0.06));
            const smallFontSize = Math.max(16, Math.floor(canvas.width * 0.03));
            
            ctx.fillStyle = "white";
            ctx.font = `bold ${fontSize}px Arial`;
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText("Game Over!", canvas.width / 2, canvas.height / 2 - fontSize);
            
            ctx.font = `${smallFontSize}px Arial`;
            ctx.fillText(`Score: ${score} points`, canvas.width / 2, canvas.height / 2);
            ctx.fillText(`Coins: ${coins}`, canvas.width / 2, canvas.height / 2 + smallFontSize * 1.5);
            ctx.fillText("Tap or Press SPACE to play again", canvas.width / 2, canvas.height / 2 + smallFontSize * 3.5);
        }
        
        // Draw start screen
        function drawStartScreen() {
            ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            const fontSize = Math.max(20, Math.floor(canvas.width * 0.06));
            const smallFontSize = Math.max(16, Math.floor(canvas.width * 0.03));
            
            ctx.fillStyle = "white";
            ctx.font = `bold ${fontSize}px Arial`;
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText("Flappy Duck Adventure", canvas.width / 2, canvas.height / 2 - fontSize);
            
            ctx.font = `${smallFontSize}px Arial`;
            ctx.fillText("Tap or Press SPACE to start", canvas.width / 2, canvas.height / 2 + smallFontSize);
            
            // Draw a yellow duck icon
            const duckSize = Math.floor(canvas.width * 0.1);
            ctx.fillStyle = "yellow";
            ctx.beginPath();
            ctx.arc(canvas.width / 2, canvas.height / 2 + smallFontSize * 3, duckSize/2, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = "orange";
            ctx.beginPath();
            ctx.moveTo(canvas.width / 2 + duckSize/2, canvas.height / 2 + smallFontSize * 3);
            ctx.lineTo(canvas.width / 2 + duckSize, canvas.height / 2 + smallFontSize * 3 + duckSize/4);
            ctx.lineTo(canvas.width / 2 + duckSize/2, canvas.height / 2 + smallFontSize * 3 + duckSize/2);
            ctx.fill();
        }
        
        // Main game loop
        function gameLoop() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw background
            drawBackground();
            
            if (gameStarted) {
                // Draw game elements
                drawObstacles();
                drawCoins();
                drawDuck();
                
                // Update game state
                update();
                
                // Draw game over screen if game is over
                if (gameOver) {
                    drawGameOver();
                }
                
                // Draw pause screen if game is paused
                if (gamePaused) {
                    const fontSize = Math.max(20, Math.floor(canvas.width * 0.06));
                    const smallFontSize = Math.max(16, Math.floor(canvas.width * 0.03));
                    
                    ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    ctx.fillStyle = "white";
                    ctx.font = `bold ${fontSize}px Arial`;
                    ctx.textAlign = "center";
                    ctx.textBaseline = "middle";
                    ctx.fillText("Game Paused", canvas.width / 2, canvas.height / 2 - fontSize/2);
                    
                    ctx.font = `${smallFontSize}px Arial`;
                    ctx.fillText("Tap Pause button to resume", canvas.width / 2, canvas.height / 2 + smallFontSize);
                }
            } else {
                // Show start screen
                drawStartScreen();
            }
            
            // Continue game loop
            animationFrame = requestAnimationFrame(gameLoop);
        }
        
        // Flap function
        function flapWings() {
            if (gameStarted && !gamePaused && !gameOver) {
                duck.velocityY = duck.flapPower;
            } else if (!gameStarted) {
                initGame();
            } else if (gameOver) {
                initGame();
            }
        }
        
        // Keyboard input handling
        document.addEventListener("keydown", function(event) {
            if (event.key === " " || event.code === "Space") {
                event.preventDefault(); // Prevent space from scrolling the page
                flapWings();
            }
            
            // Pause game with Escape
            if ((event.key === "Escape" || event.code === "Escape") && gameStarted && !gameOver) {
                togglePause();
            }
        });
        
        // Toggle pause function
        function togglePause() {
            gamePaused = !gamePaused;
            pauseButton.textContent = gamePaused ? "Resume" : "Pause";
        }
        
        // Mobile tap area for flapping
        mobileTapArea.addEventListener("touchstart", function(event) {
            event.preventDefault(); // Prevent default touch behavior
            flapWings();
        });
        
        // Button event listeners
        restartButton.addEventListener("click", function() {
            initGame();
        });
        
        pauseButton.addEventListener("click", function() {
            if (gameStarted && !gameOver) {
                togglePause();
            }
        });
        
        // Prevent default touch behavior on the canvas
        canvas.addEventListener("touchstart", function(event) {
            event.preventDefault();
        });
        
        // Initialize and start game loop
        gameLoop();
    });
</script>
